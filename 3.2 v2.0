3.2 优化的表项同步模块
由3.1介绍的传统表项同步方案，通过在内存中维护一个 shadow表，比较软表与局域网交换机（LAN switch，LSW）中实际L2表项中的硬表，从而得知上一次检查与本次检查L2表项发生的变化，通过RDP消息将这一变化告知备板，让备板对应主板所存在的表项做出增添、删除、修改的相关操作来保持主备表项的一致。
	本次设计所使用的SCU为BCM56334交换芯片，其硬表有32768条，上一代交换芯片 BCM56302总共有8192条表项，由于BCM56334的表项深度为其4倍，因此BCM56334交换芯片的同步时间相对于BCM56302交换芯片会大幅度增加。
	为了减低CPU系统占用率，将遍历一次表项时间设置为最小3s，每次读取512条并比较，当表项不变化时，处理速度较快，3s的时间大部分为空闲时间，完整的一次比较需读取64次。因此当系统学习到一条表项，其同步时间应为0-3s，平均为1.5s。对于大量表项变化的场景，表项同步机制耗时远远大于3s，主要瓶颈在于RDP消息，RDP是一种可靠的传输协议，发送时，先申请资源，将data发送至远端，待收到远端回复的ack后，释放资源，才会发送下一条。通过实际测量，在linux下，发送一条消息耗时约为4ms，因此在出现N条表项变化时，其发送RDP消息就需耗时N*4 ms，当存在20000条源MAC变化的报文后，同步至对板需耗时80s。
3.2.1.1 RDP协议分析（RFC1151协议）
	RDP协议提供了简单可靠的数据流投递服务。但该协议不提供自动的拆包、组包，因此它发送的数据包大小必须符合以太网帧的长度限制。
	RDP使用了一个较为简单的流程控制：流程控制是以停止－等待为基础的，也就是说滑动窗口大小为一。直到上一个数据包收到确认信息的时候，一个新的数据包才会被发送出去。每一次发送，发送的CPU都会等待对端CPU的ACK信息。如果发送的CPU在一定时间内没有收到确认，重新发送原始数据。RDP是BCM开发的私有协议，原为\stacking\rdp.c，现为drv\GESW_RDP.c。在SCUa中，“TRUNK组同步消息”、“BAM同步消息”、“L2同步消息”等都通过RDP消息进行板间可靠的消息同步。
   RDP报文格式：
MAC头	SNAP协议头	STK协议头	RDP协议头	PARC头	Data
  18Byte      6Byte           4Byte       16Byte      8Byte

	详细结构图：
从图中可以看出RDP有MAC头，SNAP头和STK头，这部分与消息分发中心（Message Dispatch Center，MDP）相同，但RDP报文的STK头中stk_type域为bbbb，而MDP报文的STK头中stk_bype域为aaaa。
	MDP是华为公司网管平台（intergrated Management Application Platform，iMAP）的核心模块，系统的各个模块之间的通信都要经过MDP。各个模块之间的信息都要先与MDP建立socket连接，然后与其它模块进行通信。在这个概念的支撑下，可以把MDP作为连接的服务器端，把其他进程模块作为客户端，如下图所示：

MDP作为iMAP的核心模块，是消息分发传递的中转站，应用进程与它建立连接然后进行通信
3.2.1.2 RDP的数据流的处理流程
	数据包处理之前的流程图
	数据包处理流程图
RDP消息发送分为2种：上层调用发送接口进行发送、重发机制实现消息发送。两种发送的流程分别如下：

   RDP的消息发送流程图


3.2.1.3 RDP消息类型
现有RDP消息类型如下：
1．TRUNK_SET
2．BAM_INFO_SYNC
3．LINK_CHANGE_NOTIFY
4．L2_CHANGE_NOTIFY
5．PLACP_NOTIFY
6．CRC_ALM_NOTIFY    
7．PROTECT_GRP_NOTIFY
8．PORT_CONTROL
9．L2_FAULT_NOTIFY
代码中有如下定义：
typedef enum tagGeswMsgFuncEnum
{
    GESW_MSG_TRUNK_SET,
    GESW_MSG_LINKCHANGE_NOTIFY,
    GESW_MSG_L2_CHANGE_NOTIFY
    GESW_MSG_BAM_CHECK_START
    GESW_MSG_BAM_INFO_SYNC
    GESW_MSG_PLACP_NOTIFY
    GESW_MSG_UNKNOWN
}GESW_MSG_FUNC_ENUM

若需要增加消息类型，则首先需要在上述枚举中增加类型，然后定义如下类型的消息结构（PARC头），然后增加相应发送和接收后处理代码即可。
typedef struct tagGeswReqInfoStruct{
    GESW MSG FUNC ENUM  enMsgFuncs;/需要执行的操作/
    UNIT32              u1Param;/操作需要的主要参数/
    GESW_REQ_PARAM_UNION unionParam;/操作需要的详细参数/
}

3.2.2 改进的RDP消息传输机制
	由3.2.1介绍的传统方案采用的RDP消息机制来完成主备倒换时，会产生大量的未知单播。这是由于主备单板通过RDP消息机制进行同步速度过慢，转发率过低，导致大量表项被丢弃。这是由于RDP是一种可靠的传输协议，发送时，先申请资源，将data发送至远端，待收到远端回复的ack后，释放资源，才会发送下一条。通过实际测量，在linux下，发送一条消息耗时约为4ms，因此在出现N条表项变化时，其发送RDP消息就需耗时N*4 ms，当出现20000条源MAC变化的报文后，同步至对板需耗时80s。
	为了避免出现未知单播，使接收报文的设备可以收到报文，并能查到这个报文后续的转发路径，本文提出了一个优化的L2表项同步方案，通过创建新的RDP结构体来替代原有机制每次发送只携带一条表项。相比原有机制，能有效的提高发送效率，缩短同步时间。
	由上述可知RDP使一种可靠的消息传输机制，常用来进行可靠的板间消息同步，让备板及时作出反应，可见该消息机制影响着同步时间。
RDP的数据流的处理流程
	数据包处理之前的流程图
	数据包处理流程图
RDP消息发送分为2种：上层调用发送接口进行发送、重发机制实现消息发送。两种发送的流程分别如下：

   RDP的消息发送流程图
	从上图中可以看出，RDP发送消息时，先申请资源，将data发送至远端，待收到远端回复的ack后，释放资源，才会发送下一条。
RFC1242定义了时延测量定时器，当报文的最后一位进入交换机（T0）时，启动该定时器；当报文的第一位离开交换机（T1）时，停止该定时器。
LIFO = FIFO - (Packet size in bits/Link speed)
RFC4689定义了时延测量定时器，当报文的最后一位进入交换机时，启动时延测量定时器，当报文的最后一位离开交换机时，停止时延测量定时器。配图：
	在linux系统下，经过测量，发送一条消息耗时约为4ms，因此在出现N条表项变化时，其转发RDP消息到下一模块就需耗时N*4 ms，在通过Tesgine构造20000条源MAC变化的报文后，同步至对板需耗时80s。显然这个时间是无法接受的，因此对RDP消息机制进行优化是很有必要的。本文采取对RDP消息机制的发送模块采取批量化处理的优化策略。在CPU占用率不超过35%的条件下，批量化处理表项个数能大幅度提高表项同步效率。
介绍转发相关公式
建立批量化的表项个数与流量的关系
3.2.3 FIFO处理方式
FIFO(FirstInFirstOut)是一种采用环形存储结构的先进先出存储器。其使用一个双端口存储器存放数据，数据发送方在一端写入数据，接收方在另一端读出数据，能够协调好两个时钟域的工作，满足高时钟频率的要求。FIFO在FPGA设计中主要用来缓冲数据和隔离时钟或相位差异。访问FIFO时不需要地址线，只需要数据线和读写控制信号线，且数据地址由内部读写指针自动加1完成，因此利用FIFO实现数据的缓存具有接口简单、读写方便的优点。FIFO存储数据计数器控制逻辑RTL级原理图：
L2_MOD_FIFO表是允许一个便利的用L2_ENTRY table改变和更新的方式通知主处理器入口的深处。L2_MOD_FIFO表保存L2_ENTRY表的所有改变。当L2_MOD_FIFO充满时CMIC实现一个新的FIFO DMA引擎来自动转储L2_MOD_FIFO的内容到CPU的主存。L2 MOD FIFO能够通过硬件快速得知表项变化，当表项发生变化时，L2 MOD FIFO便会得到一条变化的表项，并能获知具体发生了什么变化，具体结构如下图：
（三线表）
OPERATION:指示表项发生了什么变化
	BUCKET_INDEX,ENTRY_INDEX:变化表项的在表项中的具体位置
	L2_ENTRY_DATA:对应的具体表项内容
	从L2_MOD_FIFO表可以看出
	FIFO只有128条，我们通过DMA（直接内存读取）的方式，将上述表项送至内存中，直接读取内存中的表项，通知备板执行相应操作。
3.2.3.1 DMA基本原理
直接内存访问（Direct Memory Access，DMA)）是一种硬件机制，它允许外围设备和主内存之间直接传输它们的I/O数据，而不需要系统处理器的参与。使用这种机制可以大大提高与设备通信的吞吐量。在实现DMA传输时，是由DMA控制器直接掌管总线，因此，存在着一个总线控制权转移问题。即DMA传输前，CPU要把总线控制权交给DMA控制器，而在结束DMA传输后，DMA控制器应立即把总线控制权再交回给CPU。一个完整的DMA传输过程主要经过以下几个步骤：DMA请求、DMA响应、DMA传输、DMA结束
DMA 原理图：
mTCA V2 L2表项同步沿袭了mTCA V1的方案，通过在内存中维护一个 shadow表，比较shadow表（后称 软表）与LSW(局域网交换机)中实际L2表项（后称 硬表），得知上一次检查与本次检查L2表项发送的变化，通过RDP消息（BCM开发的私有协议，RDP消息进行板间可靠的消息同步）将这一变化告知备板，让备板作出相应的操作（删除、添加对应硬表）。
