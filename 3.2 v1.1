3.1 典型的表项调度方案
3.1.1板间消息同步
3.1.2 表项消息同步
如图所示，Base以及Fabric平面的LSW是隔离的。也就是说两个平面的交换芯片不是互通的；红色表示Vlanif接口。这个接口实际上CPU用来管理VLAN的，部署在交换芯片上。一般来说Vlanif 1就是指CPU接收VLAN 1上送到CPU的数据，不会接收其他VLAN上送的数据。
为了使交换网7、8槽两块单板L2表项一致，引入交换网表项同步机制。在同一块SCU上存在硬表和软表两套表，大小一样，共计8192条表项。交换芯片硬件从某个物理端口学习到L2表项后存放于硬表（L2_ENTRY Table）中，为了让对板LSW的硬表中也包含该条表项，本板必须找到哪几条硬表是新学到的，并将新学到的硬件表项封装到L2同步消息中，以发消息的方式通知对板去添加该条表项。对板接收到本板的添加消息则将该条表项加入L2_ENTRY Table中，L2 shadow软表同步操作。同样地，如果本板硬表删除了一些表项，那么本板必须找到哪几条硬表被删除了，并将被删除的硬件表项封装到L2同步消息中，以发消息的方式通知对板去删除该条表项。对板接收到本板的删除消息则将该条表项从L2_ENTRY Table中删除，L2 shadow软表同步操作。
交换网起了一个bcmL2X.0任务用于表项同步，_soc_l2x_thread（），该任务运行前，需要先指定同步完成8192条表项需要搬移的次数chunk_count=16次，那么每次需要同步表项的大小即为chunk_size=8192/16=512条；同步任务每3s内共搬移16次，完成8192条表现扫描，每次从硬表拷贝512条表项到内存，循环调用_soc_l2x_sync_bucket（）函数与shadow软表进行比较；_soc_l2x_sync_bucket函数每调用一次完成一个硬件bucket（slot0 ~ slot7共8条表项）的比较同步任务，比较过程中，硬件bucket中的每一条表项将同shadow bucket中的8条软表进行遍历比较，在比较前需要忽略HITDAf、HITSAf、ODD_PARITYf域，即如果硬表与软表在以上五项中存在差异则不认为软、硬表不一致。如果硬表存在而软表不存在，则通过soc_l2x_callback执行表项添加回调，向对板发送表项添加消息，相反地如果硬表不存在而软表存在，则通过soc_l2x_callback执行表项删除回调，向对板发送表项删除消息，完成上述操作后判断软、硬bucket桶是否完全一致，如果不完全一致则调用sal_memcpy将硬bucket完全覆盖软bucket。
7、8槽单板中，当其中一侧某个端口硬表项发生变化后，则本板的bcmL2X.0任务在循环遍历扫描，在这个过程中该端口硬表的变化就会被发现，然后本板向对板发送L2表项同步消息，对板接收到消息后做相应的添加或删除操作。
循环任务中会循环读取当前硬表总数，如果硬表总数大于6000条或存在某个bucket桶的8个子项被装满，则L2表项老化会开启，老化时间设定为300秒，当总表项条数少于4000并且bucket占用量小于等于7时，表项老化将被关闭。
3.2 优化的表项同步模块
由3.1介绍的传统表项同步方案，通过在内存中维护一个 shadow表，比较软表与局域网交换机（LAN switch，LSW）中实际L2表项中的硬表，从而得知上一次检查与本次检查L2表项发生的变化，通过RDP消息将这一变化告知备板，让备板对应主板所存在的表项做出增添、删除、修改的相关操作来保持主备表项的一致。
	本次设计所使用的SCU为BCM56334交换芯片，其硬表有32768条，上一代交换芯片 BCM56302总共有8192条表项，由于BCM56334的表项深度为其4倍，因此BCM56334交换芯片的同步时间相对于BCM56302交换芯片会大幅度增加。
	为了减低CPU系统占用率，将遍历一次表项时间设置为最小3s，每次读取512条并比较，当表项不变化时，处理速度较快，3s的时间大部分为空闲时间，完整的一次比较需读取64次。因此当系统学习到一条表项，其同步时间应为0-3s，平均为1.5s。对于大量表项变化的场景，表项同步机制耗时远远大于3s，主要瓶颈在于RDP消息，RDP是一种可靠的传输协议，发送时，先申请资源，将data发送至远端，待收到远端回复的ack后，释放资源，才会发送下一条。通过实际测量，在linux下，发送一条消息耗时约为4ms，因此在出现N条表项变化时，其发送RDP消息就需耗时N*4 ms，当存在20000条源MAC变化的报文后，同步至对板需耗时80s。
3.2.1.1 RDP协议分析（RFC1151协议）
	RDP协议提供了简单可靠的数据流投递服务。但该协议不提供自动的拆包、组包，因此它发送的数据包大小必须符合以太网帧的长度限制。
	RDP使用了一个较为简单的流程控制：流程控制是以停止－等待为基础的，也就是说滑动窗口大小为一。直到上一个数据包收到确认信息的时候，一个新的数据包才会被发送出去。每一次发送，发送的CPU都会等待对端CPU的ACK信息。如果发送的CPU在一定时间内没有收到确认，重新发送原始数据。RDP是BCM开发的私有协议，原为\stacking\rdp.c，现为drv\GESW_RDP.c。在SCUa中，“TRUNK组同步消息”、“BAM同步消息”、“L2同步消息”等都通过RDP消息进行板间可靠的消息同步。
   RDP报文格式：
MAC头	SNAP协议头	STK协议头	RDP协议头	PARC头	Data
  18Byte      6Byte           4Byte       16Byte      8Byte

	详细结构图：
从图中可以看出RDP有MAC头，SNAP头和STK头，这部分与消息分发中心（Message Dispatch Center，MDP）相同，但RDP报文的STK头中stk_type域为bbbb，而MDP报文的STK头中stk_bype域为aaaa。
	MDP是华为公司网管平台（intergrated Management Application Platform，iMAP）的核心模块，系统的各个模块之间的通信都要经过MDP。各个模块之间的信息都要先与MDP建立socket连接，然后与其它模块进行通信。在这个概念的支撑下，可以把MDP作为连接的服务器端，把其他进程模块作为客户端，如下图所示：

MDP作为iMAP的核心模块，是消息分发传递的中转站，应用进程与它建立连接然后进行通信
3.2.1.2 RDP的数据流的处理流程
	数据包处理之前的流程图
	数据包处理流程图
RDP消息发送分为2种：上层调用发送接口进行发送、重发机制实现消息发送。两种发送的流程分别如下：

   RDP的消息发送流程图


3.2.1.3 RDP消息类型
现有RDP消息类型如下：
1．TRUNK_SET
2．BAM_INFO_SYNC
3．LINK_CHANGE_NOTIFY
4．L2_CHANGE_NOTIFY
5．PLACP_NOTIFY
6．CRC_ALM_NOTIFY    
7．PROTECT_GRP_NOTIFY
8．PORT_CONTROL
9．L2_FAULT_NOTIFY
代码中有如下定义：
typedef enum tagGeswMsgFuncEnum
{
    GESW_MSG_TRUNK_SET,
    GESW_MSG_LINKCHANGE_NOTIFY,
    GESW_MSG_L2_CHANGE_NOTIFY
    GESW_MSG_BAM_CHECK_START
    GESW_MSG_BAM_INFO_SYNC
    GESW_MSG_PLACP_NOTIFY
    GESW_MSG_UNKNOWN
}GESW_MSG_FUNC_ENUM

若需要增加消息类型，则首先需要在上述枚举中增加类型，然后定义如下类型的消息结构（PARC头），然后增加相应发送和接收后处理代码即可。
typedef struct tagGeswReqInfoStruct{
    GESW MSG FUNC ENUM  enMsgFuncs;/需要执行的操作/
    UNIT32              u1Param;/操作需要的主要参数/
    GESW_REQ_PARAM_UNION unionParam;/操作需要的详细参数/
}

3.2.2 改进的RDP消息传输机制
	由3.2.1介绍的传统方案采用的RDP消息机制来完成主备倒换时，会产生大量的未知单播。这是由于主备单板通过RDP消息机制进行同步速度过慢，转发率过低，导致大量表项被丢弃。这是由于RDP是一种可靠的传输协议，发送时，先申请资源，将data发送至远端，待收到远端回复的ack后，释放资源，才会发送下一条。通过实际测量，在linux下，发送一条消息耗时约为4ms，因此在出现N条表项变化时，其发送RDP消息就需耗时N*4 ms，当出现20000条源MAC变化的报文后，同步至对板需耗时80s。
	为了避免出现未知单播，使接收报文的设备可以收到报文，并能查到这个报文后续的转发路径，本文提出了一个优化的L2表项同步方案，通过创建新的RDP结构体来替代原有机制每次发送只携带一条表项。相比原有机制，能有效的提高发送效率，缩短同步时间。
	由上述可知RDP使一种可靠的消息传输机制，常用来进行可靠的板间消息同步，让备板及时作出反应，可见该消息机制影响着同步时间。
RDP的数据流的处理流程
	数据包处理之前的流程图
	数据包处理流程图
RDP消息发送分为2种：上层调用发送接口进行发送、重发机制实现消息发送。两种发送的流程分别如下：

   RDP的消息发送流程图
	从上图中可以看出，RDP发送消息时，先申请资源，将data发送至远端，待收到远端回复的ack后，释放资源，才会发送下一条。而通过实际测量，在linux下，发送一条消息耗时约为4ms，因此在出现N条表项变化时，其发送RDP消息就需耗时N*4 ms。因此本方案修改了RDP每次传输所携带的表项个数。在CPU占用率不超过35%的条件下，找到能达到最大转发率的表项个数能大幅度提高表项同步效率。


L2_MOD_FIFO表是允许一个便利的用L2_ENTRY table改变和更新的方式通知主处理器入口的深处。L2_MOD_FIFO表保存L2_ENTRY表的所有改变。当L2_MOD_FIFO充满时CMIC实现一个新的FIFO DMA引擎来自动转储L2_MOD_FIFO的内容到CPU的主存。L2 MOD FIFO能够通过硬件快速得知表项变化，当表项发生变化时，L2 MOD FIFO便会得到一条变化的表项，并能获知具体发生了什么变化，具体结构如下图：
（三线表）
OPERATION:指示表项发生了什么变化
	BUCKET_INDEX,ENTRY_INDEX:变化表项的在表项中的具体位置
	L2_ENTRY_DATA:对应的具体表项内容
	
	FIFO只有128条，我们通过DMA（直接内存读取）的方式，将上述表项送至内存中，直接读取内存中的表项，通知备板执行相应操作。
